import argparse
import random
import time
from typing import List, Any

from pythonosc import udp_client

from pythonosc.dispatcher import Dispatcher
from pythonosc.osc_server import ThreadingOSCUDPServer
from pythonosc.osc_server import AsyncIOOSCUDPServer

from gpiozero import Button, LED
import asyncio

import mido
mports = mido.get_output_names()
print(mports)
output = mido.open_output(mports[1])

blue = LED(25)
red = LED(23)

newstate = 0
# this handle new state of sooperlooper sent via osc
# there is a bit of overkill in setting Leds and next behavior 
# for the button since I would witness strange behavior that I could not
# reproduce while debugging
def state_handler(address, *args):
     global newstate 
     newstate = args[2]
     print(newstate)
     if newstate == 0 or newstate == 20:
       blue.off()
       red.off()
       buttons[0]["cmd"] = "record"
       buttons[0]["longcmd"] = None
     elif newstate == 2:
       red.on()
       blue.off()
       buttons[0]["cmd"] = "record"
     elif newstate == 4:
       blue.on()
       red.off()
       buttons[0]["cmd"] = "overdub"
     elif newstate == 5:
       red.on()
       blue.off()
       buttons[0]["cmd"] = "overdub"
       buttons[0]["longcmd"] = "undo"
     elif newstate == 10:
       red.off()
       blue.blink(0.25,0.25)
       buttons[0]["cmd"] = "trigger"


def default_handler(address, *args):
    print(f"DEFAULT {address}: {args}")

dispatcher = Dispatcher()
dispatcher.map("/state", state_handler)
dispatcher.set_default_handler(default_handler)

patches = [ 
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x02, 0x7E],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x03, 0x7D],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x04, 0x7C],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x05, 0x7B],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x06, 0x7A],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x07, 0x79],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x08, 0x78],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x09, 0x77],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x76],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x75],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x74],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x73],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x72],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x71],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x10, 0x70],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x11, 0x6F],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x12, 0x6E],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x13, 0x6D],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x14, 0x6C],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x15, 0x6B],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x16, 0x6A],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x17, 0x69],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x18, 0x68],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x19, 0x67],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x66],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x65],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x64],
[0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x63]
]
 
modeon = [0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x7F, 0x00, 0x00, 0x01, 0x01, 0x7F]
modeoff = [0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x7F, 0x00, 0x00, 0x01, 0x00, 0x00]
t1 = [0x7E, 0x00, 0x06, 0x01] 
ton = [0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x7F, 0x00, 0x00, 0x02, 0x01, 0x7E] 
toff = [0x41, 0x10, 0x01, 0x05, 0x0D, 0x12, 0x7F, 0x00, 0x00, 0x02, 0x00, 0x7F] 


savedpatch = 0
savedbank = 0


def midibutton(patch, bank):
  global savedpatch
  global savedbank
  if patch:
    savedpatch += patch
    if savedpatch > 29:
       savedpatch = savedpatch - 30
    elif savedpatch < 0:
       savedpatch = savedpatch + 30
  elif bank:
    savedbank += bank
    if savedbank > 2:
       savedbank = 0
  print("patch", savedpatch + savedbank)
  output.send(mido.Message('sysex', data=patches[savedpatch + savedbank], time=0))


ip = "0.0.0.0"
port = 9959
buttons = [{"but":Button(27),  "state": False, "up":0, "down":0, "count":0, "cmd":"record", "longcmd":None, "patch":None, "bank":None},
{"but":Button(2),  "state": False, "up":0, "down":0, "count":0, "cmd":None, "longcmd":None, "patch":3, "bank":None},
{"but":Button(3),  "state": False, "up":0, "down":0, "count":0, "cmd":None, "longcmd":None, "patch":-3, "bank":None},
{"but":Button(4),  "state": False, "up":0, "down":0, "count":0, "cmd":None, "longcmd":None, "patch":None, "bank":1}]

# ended up with low-tech approach since Button class
# async handlers proved unreliable 
# basically loop runs every 10ms
# debounce and long-press and double-press are 
# coded in the loop with simple counts through the loop
# kinda cheesy but seems way more reliable
async def loop():
  global newstate
  # get then intial state of button so that we can use no or nc switch
  bstart = buttons[0]["but"].is_pressed
  client = udp_client.SimpleUDPClient("127.0.0.1", 9951)
  client.send_message("/sl/-1/register_auto_update", ["state", 10, "osc.udp://127.0.0.1:9959/", "/state"])
  while True:
    for button in buttons:
      # handle debounce
      if button["count"] > 0:
        button["count"] -= 1
      else:
        b = button["but"].is_pressed != bstart
        if b != button["state"]:
          if b:
            if button["cmd"]:
              if button["up"] < 40:
                client.send_message("/sl/0/hit", "mute")
              else:
                client.send_message("/sl/0/hit", button["cmd"])
            else:
              output.send(mido.Message('sysex', data=modeon, time=0))
              output.send(mido.Message('sysex', data=ton, time=0))
              time.sleep(0.1)
              output.send(mido.Message('sysex', data=toff, time=0))
              output.send(mido.Message('sysex', data=modeoff, time=0))
              midibutton(button["patch"], button["bank"])
            button["state"] = True
            button["count"] = 10
            button["down"] = 0
          else:
            #client.send_message("/sl/0/up", button["cmd"])
            button["state"] = False
            button["count"] = 10
            button["up"] = 0
        else:
          if b:
            button["down"] += 1
            if button["down"] > 100:
               button["down"] = 0
               if newstate == 10:
                 client.send_message("/sl/0/hit", "undo_all")
               elif newstate == 5:
                 client.send_message("/sl/0/hit", "overdub")
                 client.send_message("/sl/0/hit", "undo")
                 client.send_message("/sl/0/hit", "undo")
               else:                 
                 client.send_message("/sl/0/hit", "undo")
          else:
            button["up"] += 1

    time.sleep(0.01)
    await asyncio.sleep(0)



async def init_main():
    server = AsyncIOOSCUDPServer((ip, port), dispatcher, asyncio.get_event_loop())
    transport, protocol = await server.create_serve_endpoint()  # Create datagram endpoint and start serving

    await loop()  # Enter main loop of program

    transport.close()  # Clean up serve endpoint


asyncio.run(init_main())
